var documenterSearchIndex = {"docs":
[{"location":"slice/#Slice","page":"Slice","title":"Slice","text":"","category":"section"},{"location":"slice/","page":"Slice","title":"Slice","text":"Slices are easiest way to use pointers. They are basically a data structure that holds all the needed data for pointer operations. By using this, you can create kind of a SubArray not limited by bounds. This means that something like this is perfectly possible:","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"using PointerArithmetic #hide\r\na = [1,2,3,4]\r\nslice = Slice(a, 2:3)","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"As you can see, through the use of the pointer inside of slice it was able to access the memory directly by its address.","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"note: Note\nSlices are the only subarray-like method that has bounds checking, which makes them safe.","category":"page"},{"location":"slice/#Loading-and-Storing","page":"Slice","title":"Loading and Storing","text":"","category":"section"},{"location":"slice/","page":"Slice","title":"Slice","text":"Since Slices are sort of a SubArray, changing a value inside of it affects the parent array.","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"using PointerArithmetic #hide\r\na = [1,2,3,4]\r\nslice = Slice(a, 2:3)\r\nslice[0]","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"Example of load operation","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"slice[0] = 100\r\na","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"Example of store operation","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"note: Note\nRemember, bounds are not problems here","category":"page"},{"location":"slice/#Shift","page":"Slice","title":"Shift","text":"","category":"section"},{"location":"slice/","page":"Slice","title":"Slice","text":"Slices are part of an array, increasing and decreasing its size is the same as moving the pointer, and the length of the array.","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"For this operation, there are two shifting  operators:","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"Symbol Description\n<< If positive, hides n elements at the beginning of the vector. Otherwise, it shows hidden elements there.\n>> If positive, increases the length of the array, showing new elements after the current last. Otherwise, it hides the n last shown elements.","category":"page"},{"location":"slice/","page":"Slice","title":"Slice","text":"shift_start(::Slice, ::Integer)","category":"page"},{"location":"slice/#PointerArithmetic.Pointers.shift_start-Tuple{Slice, Integer}","page":"Slice","title":"PointerArithmetic.Pointers.shift_start","text":"shift_start(sl::Slice, i::Integer)\n\nShifts the array starting point in a certain number of items. Can be called using << Usage:\n\njulia> arr = [1,2,3,4]\njulia> sl = Slice(arr, 2:3)\n2-element Slice{Int64}:\n2\n3\njulia> sl << 1\n1-element Slice{Int64}:\n3\njulia> sl << -1\n3-element Slice{Int64}:\n1\n2\n3\n\n\n\n\n\n","category":"method"},{"location":"slice/","page":"Slice","title":"Slice","text":"shift_end(::Slice, ::Integer)","category":"page"},{"location":"slice/#PointerArithmetic.ArraySlices.shift_end-Tuple{Slice, Integer}","page":"Slice","title":"PointerArithmetic.ArraySlices.shift_end","text":"shift_end(sl::Slice, i::Integer)\n\nShifts the array ending point in a certain number of items. Can be called using >> Usage:\n\njulia> arr = [1,2,3,4]\njulia> sl = Slice(arr, 2:3)\n2-element Slice{Int64}:\n2\n3\njulia> sl >> 1\n3-element Slice{Int64}:\n2\n3\n4\njulia> sl >> -1\n1-element Slice{Int64}:\n2\n\n\n\n\n\n","category":"method"},{"location":"array_slice/#ArraySlice","page":"ArraySlice","title":"ArraySlice","text":"","category":"section"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"ArraySlices are another way to use pointers. Instead of accessing addresses directly, they create another Array pointing to the address at the specified interval of the parent array.","category":"page"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"note: Note\nRead the PointerArithmetic page before using it","category":"page"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"using PointerArithmetic #hide\r\na = [1,2,3,4]\r\nslice = ArraySlice(a, 2:3)","category":"page"},{"location":"array_slice/#Loading-and-Storing","page":"ArraySlice","title":"Loading and Storing","text":"","category":"section"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"Since it makes a new array, bounds checking are mandatory. Thus, accessing out of range elements will result in an error.","category":"page"},{"location":"array_slice/#Performance","page":"ArraySlice","title":"Performance","text":"","category":"section"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"Because of the array creation, it doesn't need to access a structure to reach the pointer, but the memory already. It makes the ArraySlice to be faster than Slice and faster than a View, which is good for iterating over it.","category":"page"},{"location":"array_slice/#Shift","page":"ArraySlice","title":"Shift","text":"","category":"section"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"Shifting works just like with Slices, and it can be a way out for the problem of accessing elements out of bounds.","category":"page"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"Symbol Description\n<< If positive, hides n elements at the beginning of the vector. Otherwise, it shows hidden elements there.\n>> If positive, increases the length of the array, showing new elements after the current last. Otherwise, it hides the n last shown elements.","category":"page"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"shift_start(::AbstractArray, ::Integer)","category":"page"},{"location":"array_slice/#PointerArithmetic.Pointers.shift_start-Tuple{AbstractArray, Integer}","page":"ArraySlice","title":"PointerArithmetic.Pointers.shift_start","text":"shift_start(sl::AbstractArray, i::Integer)\n\nShifts the array starting point in a certain number of items. Can be called using << Usage:\n\njulia> arr = [1,2,3,4]\njulia> sl = ArraySlice(arr, 2:3)\n2-element Vector{Int64}:\n2\n3\njulia> sl << 1\n1-element Vector{Int64}:\n3\njulia> sl << -1\n3-element Vector{Int64}:\n1\n2\n3\n\n\n\n\n\n","category":"method"},{"location":"array_slice/","page":"ArraySlice","title":"ArraySlice","text":"shift_end(::AbstractArray, ::Integer)","category":"page"},{"location":"array_slice/#PointerArithmetic.ArraySlices.shift_end-Tuple{AbstractArray, Integer}","page":"ArraySlice","title":"PointerArithmetic.ArraySlices.shift_end","text":"shift_end(sl::AbstractArray, i::Integer)\n\nShifts the array ending point in a certain number of items. Can be called using >> Usage:\n\njulia> arr = [1,2,3,4]\njulia> sl = ArraySlice(arr, 2:3)\n2-element Vector{Int64}:\n2\n3\njulia> sl >> 1\n3-element Vector{Int64}:\n2\n3\n4\njulia> sl >> -1\n1-element Vector{Int64}:\n2\n\n\n\n\n\n","category":"method"},{"location":"pointer/#Pointer","page":"Pointer","title":"Pointer","text":"","category":"section"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"Pointers are basically the same as using the Julia builtin function pointer(array). Instead of adding a new structure, it only adds C like accessing, storing and shifting operations.","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"note: Note\nRead the PointerArithmetic page before using it","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"using PointerArithmetic #hide\r\na = [1,2,3,4]\r\nptr = Pointer(a)\r\nptr[3]","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"Also, you can shift the starting array item:","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"ptr = Pointer(a, 2)\r\nptr[1]","category":"page"},{"location":"pointer/#Loading-and-Storing","page":"Pointer","title":"Loading and Storing","text":"","category":"section"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"As mentioned earlier, storing and loading are similar to C syntax. Just like in C, you can access unbounded elements.","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"using PointerArithmetic #hide\r\na = [1,2,3,4]\r\nptr = Pointer(a, 2)\r\nptr[1]","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"ptr[-1]","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"Example of load operation","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"ptr[0] = 100\r\na","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"Example of store operation","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"note: Note\nBounds are not problems here","category":"page"},{"location":"pointer/#Shift","page":"Pointer","title":"Shift","text":"","category":"section"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"Shifting a pointer is similar to memory address manipulation. You can use the shift operator to add or subtract addresses from the base address in the pointer.","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"For this operation, there is one shifting  operator:","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"Symbol Description\n<< If positive, hides n elements at the beginning of the vector. Otherwise, it shows hidden elements there.","category":"page"},{"location":"pointer/","page":"Pointer","title":"Pointer","text":"shift_start(::Ptr, ::Integer)","category":"page"},{"location":"pointer/#PointerArithmetic.Pointers.shift_start-Tuple{Ptr, Integer}","page":"Pointer","title":"PointerArithmetic.Pointers.shift_start","text":"shift_start(ptr::Ptr, i::Integer)\n\nShifts the pointer in the specified i number of elements. Another way to call is to use ptr << nof_elements Usage:\n\njulia> a = [1,2,3,4]\njulia> pt = Pointer(a)\njulia> pt[1]\n1\njulia> pt = pt << 2\njulia> pt[1]\n3\n\n\n\n\n\n","category":"method"},{"location":"#PointerArithmetic","page":"PointerArithmetic","title":"PointerArithmetic","text":"","category":"section"},{"location":"","page":"PointerArithmetic","title":"PointerArithmetic","text":"This package allows you to manipulate slices and array pointers like in C. It is different than views because this package focuses on performance and at giving the programmer a way to access lower code features. ","category":"page"},{"location":"","page":"PointerArithmetic","title":"PointerArithmetic","text":"warning: Warning\nJust like in C, it gives you too much power to access invalid memory positions, which may cause a problems to your OS execution or application malfunctioning. Only use this library if you know exactly what you're doing.","category":"page"},{"location":"","page":"PointerArithmetic","title":"PointerArithmetic","text":"warning: Warning\nWhen using any kind of array slices or pointers, do never lose the reference for the original array. If you lose it, the garbage collector will be able to free its memory, and the slices may cause problems or they won't be accessible anymore.","category":"page"},{"location":"#Do-I-need-this-library?","page":"PointerArithmetic","title":"Do I need this library?","text":"","category":"section"},{"location":"","page":"PointerArithmetic","title":"PointerArithmetic","text":"Instead of finding the answer here, you should first ask yourself if you are planning to use C to get benefits of pointer arithmetic. If the answer is Yes, then search for some other implementations related to what you want. There are plenty of optimized codes already written. Otherwise, if you want to stay in Julia and also make use of pointers, and YOU AGREE WITH THE RISKS, then this is your lib.","category":"page"},{"location":"#References","page":"PointerArithmetic","title":"References","text":"","category":"section"},{"location":"","page":"PointerArithmetic","title":"PointerArithmetic","text":"","category":"page"}]
}
